/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package org.quiltmc.community.logs.plugins.powergems

import org.quiltmc.community.cozy.modules.logs.data.Log
import org.quiltmc.community.cozy.modules.logs.data.Order
import org.quiltmc.community.cozy.modules.logs.types.LogProcessor

private val POWERGEMS_DEBUG_EXCEPTION_REGEX =
	"""\[SealUtils] Exception triggered by ([a-zA-Z0-9.]+)""".toRegex()

private val POWERGEMS_FAKE_EXCEPTION_REGEX =
	"""\[SealUtils] The exception message is This is a fake exception for debugging purposes\.""".toRegex()

private val POWERGEMS_SEALUTILS_ERROR_REGEX =
	"""\[SealUtils] The error message is ([A-Z_]+)""".toRegex()

private val POWERGEMS_VERSION_REGEX =
	"""SealLib-([\d.\w\-]+)\.jar//""".toRegex()

private val POWERGEMS_CONFIG_DUMP_REGEX =
	"""\[SealUtils] Dump from: ([a-zA-Z]+) -> ([a-zA-Z]+): (.+)""".toRegex()

private val POWERGEMS_MANAGER_DUMP_REGEX =
	"""\[SealUtils] Dump from: ([a-zA-Z]+) -> ([a-zA-Z]+): (.+)""".toRegex()

public class PowerGemsDebugProcessor : LogProcessor() {
	override val identifier: String = "powergems_debug_processor"
	override val order: Order = Order.Earlier

	override suspend fun process(log: Log) {
		val debugException = POWERGEMS_DEBUG_EXCEPTION_REGEX.find(log.content)
		val fakeException = POWERGEMS_FAKE_EXCEPTION_REGEX.find(log.content)
		val errorMessage = POWERGEMS_SEALUTILS_ERROR_REGEX.find(log.content)?.groupValues?.get(1)
		val sealLibVersion = POWERGEMS_VERSION_REGEX.find(log.content)?.groupValues?.get(1)
		val configDumps = POWERGEMS_CONFIG_DUMP_REGEX.findAll(log.content).toList()
		
		// Handle fake debug exceptions
		if (fakeException != null && errorMessage == "FAKE_EXCEPTION") {
			log.addMessage(
				"**PowerGems Debug Command Detected** \n" +
					"This appears to be a fake exception generated by PowerGems' debug command. " +
					"This is not a real error and can be safely ignored. " +
					"If you're experiencing actual issues, please run the debug command to help identify the problem."
			)
			return // Don't mark as problem since this is intentional
		}
		
		// Handle real PowerGems exceptions
		if (debugException != null && fakeException == null) {
			val exceptionClass = debugException.groupValues[1]			log.addMessage(
				"**PowerGems Exception Detected** \n" +
					"Exception in class: `$exceptionClass`" +
					(errorMessage?.let { "\nError type: `$it`" } ?: "") +
					(sealLibVersion?.let { "\nSealLib version: `$it`" } ?: "") +
					"\n\nCheck the full stack trace above for more details."
			)
			log.hasProblems = true
		}
		
		// Analyze configuration dumps for common issues
		if (configDumps.isNotEmpty()) {
			analyzeConfigurationDumps(log, configDumps)
		}
	}
	
	private fun analyzeConfigurationDumps(log: Log, configDumps: List<MatchResult>) {
		val configMap = mutableMapOf<String, MutableMap<String, String>>()
		
		// Parse all configuration dumps
		configDumps.forEach { match ->
			val manager = match.groupValues[1]
			val key = match.groupValues[2] 
			val value = match.groupValues[3]
			
			configMap.computeIfAbsent(manager) { mutableMapOf() }[key] = value
		}
		
		val issues = mutableListOf<String>()
		
		// Check for common configuration issues
		configMap["GeneralConfigManager"]?.let { generalConfig ->
			// Check debug mode
			if (generalConfig["debugMode"] == "true") {
				issues.add("Debug mode is enabled - this may impact performance")
			}
			
			// Check if gems decay is disabled on level 1
			if (generalConfig["doGemDecayOnLevel1"] == "false" && generalConfig["doGemDecay"] == "true") {
				issues.add("Gem decay is enabled but disabled for level 1 gems")
			}
			
			// Check max gem level
			generalConfig["maxGemLevel"]?.let { maxLevel ->
				if (maxLevel.toIntOrNull()?.let { it > 10 } == true) {
					issues.add("Very high max gem level ($maxLevel) may cause balance issues")
				}
			}
		}
		
		// Check for disabled gems
		configMap["ActiveGemsConfigManager"]?.let { activeConfig ->
			val disabledGems = activeConfig.filterValues { it == "false" }.keys
			if (disabledGems.isNotEmpty()) {
				issues.add("Some gems are disabled: ${disabledGems.joinToString(", ")}")
			}
		}
		
		// Check cooldown configuration
		configMap["CooldownConfigManager"]?.let { cooldownConfig ->
			val cooldowns = cooldownConfig.values.mapNotNull { it.toIntOrNull() }
			if (cooldowns.isNotEmpty()) {
				val avgCooldown = cooldowns.average()
				if (avgCooldown < 30) {
					issues.add("Low cooldown times (avg: ${avgCooldown.toInt()}s) may cause spam")
				} else if (avgCooldown > 300) {
					issues.add("High cooldown times (avg: ${avgCooldown.toInt()}s) may frustrate players")
				}
			}
		}
		
		if (issues.isNotEmpty()) {
			log.addMessage(
				"**PowerGems Configuration Analysis** \n" +
					"Potential configuration issues detected:\n" +
					issues.joinToString("\n") { "â€¢ $it" } +
					"\n\n*This analysis is based on the debug dump. Review your PowerGems configuration if needed.*"
			)
		}
	}
}
