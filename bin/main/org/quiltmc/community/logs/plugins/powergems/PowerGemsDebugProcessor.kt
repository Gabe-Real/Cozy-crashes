/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package org.quiltmc.community.logs.plugins.powergems

import dev.kordex.core.DISCORD_GREEN
import org.quiltmc.community.cozy.modules.logs.data.Log
import org.quiltmc.community.cozy.modules.logs.data.Order
import org.quiltmc.community.cozy.modules.logs.types.LogProcessor

private val POWERGEMS_DEBUG_EXCEPTION_REGEX =
	"""\[SealUtils] Exception triggered by ([a-zA-Z0-9.]+)""".toRegex()

private val POWERGEMS_FAKE_EXCEPTION_REGEX =
	"""\[SealUtils] The exception message is This is a fake exception for debugging purposes\.""".toRegex()

private val POWERGEMS_SEALUTILS_ERROR_REGEX =
	"""\[SealUtils] The error message is ([A-Z_]+)""".toRegex()

private val POWERGEMS_VERSION_REGEX =
	"""PowerGems-([\d.\w\-]+)\.jar//""".toRegex()

private val POWERGEMS_CONFIG_DUMP_REGEX =
	"""\[SealUtils] Dump from: ([a-zA-Z]+) -> ([a-zA-Z]+): (.+)""".toRegex()

private val POWERGEMS_COMMAND_ERROR_REGEX =
	"""\[SealUtils] Exception triggered by ([a-zA-Z0-9.]+Command)""".toRegex()

private val POWERGEMS_INDEX_OUT_OF_BOUNDS_REGEX =
	"""\[SealUtils] The exception message is Index (\d+) out of bounds for length (\d+)""".toRegex()

public class PowerGemsDebugProcessor : LogProcessor() {
	override val identifier: String = "powergems_debug_processor"
	override val order: Order = Order.Earlier
	override suspend fun process(log: Log) {
		val debugException = POWERGEMS_DEBUG_EXCEPTION_REGEX.find(log.content)
		val fakeException = POWERGEMS_FAKE_EXCEPTION_REGEX.find(log.content)
		val errorMessage = POWERGEMS_SEALUTILS_ERROR_REGEX.find(log.content)?.groupValues?.get(1)
		val powerGemsVersion = POWERGEMS_VERSION_REGEX.find(log.content)?.groupValues?.get(1)
		val configDumps = POWERGEMS_CONFIG_DUMP_REGEX.findAll(log.content).toList()
		val commandError = POWERGEMS_COMMAND_ERROR_REGEX.find(log.content)
		val indexOutOfBounds = POWERGEMS_INDEX_OUT_OF_BOUNDS_REGEX.find(log.content)
		
		// Handle fake debug exceptions
		if (fakeException != null && errorMessage == "FAKE_EXCEPTION") {
			log.addMessage(
				"**PowerGems Debug Command Detected** \n" +
					"This appears to be a fake exception generated by PowerGems' debug command. " +
					"This is not a real error and can be safely ignored. " +
					"If you're experiencing actual issues, please run the debug command to help identify the problem."
			)
			return // Don't mark as problem since this is intentional
		}
		
		// Handle real PowerGems exceptions
		if (debugException != null && fakeException == null) {
			val exceptionClass = debugException.groupValues[1]
			
			var errorDescription = "Exception in class: `$exceptionClass`"
			errorDescription += errorMessage?.let { "\nError type: `$it`" } ?: ""
			errorDescription += powerGemsVersion?.let { "\nPowerGems version: `$it`" } ?: ""
			
			// Add specific guidance for command errors
			if (commandError != null) {
				val commandName = commandError.groupValues[1]
				errorDescription += "\n\n**Command Error Detected**"
				
				if (indexOutOfBounds != null) {
					val index = indexOutOfBounds.groupValues[1]
					val length = indexOutOfBounds.groupValues[2]
					errorDescription += "\n• Index out of bounds error: trying to access index $index in array of length $length"
					
					when (commandName) {
						"dev.iseal.powergems.commands.GiveGemCommand" -> {
							errorDescription += "\n• **Fix**: Use correct command syntax: `/givegem <player> <gem_type> [level]`"
							errorDescription += "\n• Common issue: Missing required arguments or invalid gem type"
						}
						else -> {
							errorDescription += "\n• **Fix**: Check command arguments - you may be missing required parameters"
						}
					}
				}
			}
			
			errorDescription += "\n\nCheck the full stack trace above for more details."
			
			log.addMessage("**PowerGems Exception Detected** \n$errorDescription")
			log.hasProblems = true
		}
		
		// Analyze configuration dumps for common issues
		if (configDumps.isNotEmpty()) {
			analyzeConfigurationDumps(log, configDumps)
		}
	}
		private fun analyzeConfigurationDumps(log: Log, configDumps: List<MatchResult>) {
		val configMap = mutableMapOf<String, MutableMap<String, String>>()
		
		// Parse all configuration dumps
		configDumps.forEach { match ->
			val manager = match.groupValues[1]
			val key = match.groupValues[2] 
			val value = match.groupValues[3]
			
			configMap.computeIfAbsent(manager) { mutableMapOf() }[key] = value
		}
		
		val issues = mutableListOf<String>()
		
		// Check for common configuration issues
		configMap["GeneralConfigManager"]?.let { generalConfig ->
			// Check debug mode
			if (generalConfig["debugMode"] == "true") {
				issues.add("Debug mode is enabled - this may impact performance")
			}
			
			// Check if gems decay is disabled on level 1
			if (generalConfig["doGemDecayOnLevel1"] == "false" && generalConfig["doGemDecay"] == "true") {
				issues.add("Gem decay is enabled but disabled for level 1 gems")
			}
			
			// Check max gem level
			generalConfig["maxGemLevel"]?.let { maxLevel ->
				if (maxLevel.toIntOrNull()?.let { it > 10 } == true) {
					issues.add("Very high max gem level ($maxLevel) may cause balance issues")
				}
			}
		}
		
		// Check for disabled gems
		configMap["ActiveGemsConfigManager"]?.let { activeConfig ->
			val disabledGems = activeConfig.filterValues { it == "false" }.keys
			if (disabledGems.isNotEmpty()) {
				issues.add("Some gems are disabled: ${disabledGems.joinToString(", ")}")
			}
		}
		
		// Check cooldown configuration
		configMap["CooldownConfigManager"]?.let { cooldownConfig ->
			val cooldowns = cooldownConfig.values.mapNotNull { it.toIntOrNull() }
			if (cooldowns.isNotEmpty()) {
				val avgCooldown = cooldowns.average()
				if (avgCooldown < 30) {
					issues.add("Low cooldown times (avg: ${avgCooldown.toInt()}s) may cause spam")
				} else if (avgCooldown > 300) {
					issues.add("High cooldown times (avg: ${avgCooldown.toInt()}s) may frustrate players")
				}
			}
		}
		
		// Create summary message with issues
		if (issues.isNotEmpty()) {
			log.addMessage(
				"**PowerGems Configuration Analysis** \n" +
					"Potential configuration issues detected:\n" +
					issues.joinToString("\n") { "• $it" } +
					"\n\n*Review the detailed configuration dump below.*"
			)
		}
				// Create paged embeds for configuration dumps
		createConfigurationEmbeds(log, configMap)
	}	private fun createConfigurationEmbeds(log: Log, configMap: Map<String, Map<String, String>>) {
		if (configMap.isEmpty()) return
		
		val managers = configMap.keys.toList()
		val totalPages = managers.size
		
		// Create individual embeds for each manager with very conservative limits
		managers.forEachIndexed { index, manager ->
			val config = configMap[manager] ?: return@forEachIndexed
			
			val embedTitle = "PowerGems Config: $manager"
			val embedDescription = "Configuration for $manager (${index + 1}/$totalPages)"
			
			val sortedEntries = config.entries.sortedBy { it.key }
			
			// Very conservative approach: max 3 entries per embed to prevent size issues
			val chunks = sortedEntries.chunked(3)
			
			chunks.forEachIndexed { chunkIndex, chunk ->
				log.embed {
					title = if (chunks.size > 1) "$embedTitle (Part ${chunkIndex + 1}/${chunks.size})" else embedTitle
					description = embedDescription
					color = DISCORD_GREEN
					
					// Add entries as individual fields
					chunk.forEach { entry ->
						val truncatedValue = if (entry.value.length > 100) {
							"${entry.value.take(100)}..."
						} else {
							entry.value
						}
						
						field {
							name = entry.key.take(200) // Keep field names shorter
							value = "```\n$truncatedValue\n```".take(800) // Very conservative field value limit
							inline = false
						}
					}
					
					footer {
						text = "PowerGems Debug • Part ${chunkIndex + 1}/${chunks.size}"
					}
				}
			}
		}
	}
}
