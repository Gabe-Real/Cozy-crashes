/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package org.quiltmc.community.logs.plugins.powergems

import org.quiltmc.community.cozy.modules.logs.data.Log
import org.quiltmc.community.cozy.modules.logs.data.Order
import org.quiltmc.community.cozy.modules.logs.types.LogProcessor

private val POWERGEMS_DEBUG_EXCEPTION_REGEX =
	"""\[SealUtils] Exception triggered by ([a-zA-Z0-9.]+)""".toRegex()

private val POWERGEMS_FAKE_EXCEPTION_REGEX =
	"""\[SealUtils] The exception message is This is a fake exception for debugging purposes\.""".toRegex()

private val POWERGEMS_SEALUTILS_ERROR_REGEX =
	"""\[SealUtils] The error message is ([A-Z_]+)""".toRegex()

private val POWERGEMS_EXCEPTION_MESSAGE_REGEX =
	"""\[SealUtils] The exception message is (.+)""".toRegex()

private val POWERGEMS_STACKTRACE_REGEX =
	"""\[SealUtils] The stacktrace and all of its details known are as follows:""".toRegex()

private val POWERGEMS_VERSION_REGEX =
	"""PowerGems-([0-9.]+(?:-[A-Z0-9]+)?)\.jar//""".toRegex()

private val POWERGEMS_CONFIG_DUMP_REGEX =
	"""\[SealUtils] Dump from: ([a-zA-Z]+) -> ([a-zA-Z]+): (.+)""".toRegex()

private val POWERGEMS_MANAGER_DUMP_REGEX =
	"""\[SealUtils] Dump from: ([a-zA-Z]+) -> ([a-zA-Z]+): (.+)""".toRegex()

private val POWERGEMS_PLUGIN_VERSION_REGEX =
	"""\[PowerGems] PowerGems v([0-9.]+(?:-[A-Z0-9]+)?)""".toRegex()

private val POWERGEMS_COMMAND_ERROR_REGEX =
	"""\[PowerGems] Loading server plugin PowerGems v([0-9.]+(?:-[A-Z0-9]+)?)""".toRegex()

public class PowerGemsDebugProcessor : LogProcessor() {
	override val identifier: String = "powergems_debug_processor"
	override val order: Order = Order.Earlier
	override suspend fun process(log: Log) {
		val debugException = POWERGEMS_DEBUG_EXCEPTION_REGEX.find(log.content)
		val fakeException = POWERGEMS_FAKE_EXCEPTION_REGEX.find(log.content)
		val errorMessage = POWERGEMS_SEALUTILS_ERROR_REGEX.find(log.content)?.groupValues?.get(1)
		val exceptionMessage = POWERGEMS_EXCEPTION_MESSAGE_REGEX.find(log.content)?.groupValues?.get(1)
		val hasStacktrace = POWERGEMS_STACKTRACE_REGEX.find(log.content) != null
		val powerGemsVersion = POWERGEMS_VERSION_REGEX.find(log.content)?.groupValues?.get(1)
			?: POWERGEMS_PLUGIN_VERSION_REGEX.find(log.content)?.groupValues?.get(1)
		val configDumps = POWERGEMS_CONFIG_DUMP_REGEX.findAll(log.content).toList()
		
		// Handle fake debug exceptions
		if (fakeException != null && errorMessage == "FAKE_EXCEPTION") {
			log.addMessage(
				"**PowerGems Debug Command Detected** \n" +
					"This appears to be a fake exception generated by PowerGems' debug command. " +
					"This is not a real error and can be safely ignored. " +
					"If you're experiencing actual issues, please run the debug command to help identify the problem."
			)
			return // Don't mark as problem since this is intentional
		}
		
		// Handle real PowerGems exceptions
		if (debugException != null && fakeException == null) {
			val exceptionClass = debugException.groupValues[1]
			val messageBuilder = StringBuilder("**PowerGems Exception Detected** \n")
			messageBuilder.append("Exception in class: `$exceptionClass`")
			
			errorMessage?.let { 
				messageBuilder.append("\nError type: `$it`")
				
				// Provide specific help for common error types
				when (it) {
					"GIVE_GEM_COMMAND" -> {
						messageBuilder.append("\n\n**Common Cause:** This often happens when using the `/givegem` command without proper arguments.")
						messageBuilder.append("\n**Solution:** Use the command like `/givegem <player> <gemtype> [level]`")
						messageBuilder.append("\nExample: `/givegem Steve fire 3`")
					}
					"INVALID_GEM_TYPE" -> {
						messageBuilder.append("\n\n**Common Cause:** Invalid gem type specified.")
						messageBuilder.append("\n**Solution:** Use valid gem types: Fire, Water, Earth, Air, Lightning, Ice, Healing, Strength, Iron, Sand")
					}
				}
			}
			
			exceptionMessage?.let { 
				messageBuilder.append("\nException message: `$it`")
				
				// Handle specific exception messages
				if (it.contains("Index") && it.contains("out of bounds")) {
					messageBuilder.append("\n\n**Common Cause:** This is likely caused by missing command arguments or empty lists.")
					messageBuilder.append("\n**Solution:** Check that all required parameters are provided when using PowerGems commands.")
				}
			}
			
			powerGemsVersion?.let { messageBuilder.append("\nPowerGems version: `$it`") }
			
			if (hasStacktrace) {
				messageBuilder.append("\n\nFull stack trace and debug information is included above.")
			}
			
			log.addMessage(messageBuilder.toString())
			log.hasProblems = true
		}
		
		// Analyze configuration dumps for common issues
		if (configDumps.isNotEmpty()) {
			analyzeConfigurationDumps(log, configDumps)
		}	}
	
	private fun analyzeConfigurationDumps(log: Log, configDumps: List<MatchResult>) {
		val configMap = mutableMapOf<String, MutableMap<String, String>>()
		
		// Parse all configuration dumps
		configDumps.forEach { match ->
			val manager = match.groupValues[1]
			val key = match.groupValues[2] 
			val value = match.groupValues[3]
			
			configMap.computeIfAbsent(manager) { mutableMapOf() }[key] = value
		}
		
		val issues = mutableListOf<String>()
				// Check cooldown configuration
		configMap["CooldownConfigManager"]?.let { cooldownConfig ->
			val cooldowns = cooldownConfig.values.mapNotNull { it.toIntOrNull() }
			if (cooldowns.isNotEmpty()) {
				val minCooldown = cooldowns.minOrNull() ?: 0
				
				// Only flag extremely problematic cooldowns
				if (minCooldown < 5) {
					issues.add("Very low cooldown times detected (min: ${minCooldown}s) - may cause ability spam")
				}
			}
		}
				// Check gem color configuration
		// Note: PowerGems uses custom model data for gem distinction, so same base color is normal
		
		// Check gem material configuration  
		// Note: PowerGems uses custom model data for gem distinction, so same base material is normal
		
		// Check permanent effects
		// Note: Some gems logically share effects (e.g., Fire and Lava both having fire resistance)
				// Check gem level effects
		configMap["GemPermanentEffectLevelConfigManager"]?.let { levelConfig ->
			val levels = levelConfig.values.mapNotNull { it.toIntOrNull() }
			if (levels.isNotEmpty()) {
				val minLevel = levels.minOrNull() ?: 0
				// Only flag actually problematic effect levels
				if (minLevel < 1) {
					issues.add("Some permanent effects have level 0 or negative - effects may not work properly")
				}
			}
		}
		
		// Look for specific error patterns in the dump
		val gemManagerDumps = configDumps.filter { it.groupValues[1] == "GemManager" }
		if (gemManagerDumps.isNotEmpty()) {
			val gemIdLookup = gemManagerDumps.find { it.groupValues[2] == "gemIdLookup" }?.groupValues?.get(3)
			if (gemIdLookup != null && gemIdLookup.contains("[]")) {
				issues.add("Empty gem ID lookup - no gems may be registered properly")
			}
		}		
		// Only show message if there are actual issues
		if (issues.isNotEmpty()) {
			log.addMessage(
				"**PowerGems Configuration Issues** \n" +
					"⚠️ Potential problems detected:\n" +
					issues.joinToString("\n") { "• $it" }
			)
		}
	}
}
