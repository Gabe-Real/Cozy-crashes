/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package org.quiltmc.community.logs.plugins.powergems

import dev.kord.core.behavior.channel.createEmbed
import dev.kord.rest.builder.message.embed
import org.quiltmc.community.cozy.modules.logs.data.Log
import org.quiltmc.community.cozy.modules.logs.data.Order
import org.quiltmc.community.cozy.modules.logs.types.LogProcessor

private val POWERGEMS_DEBUG_EXCEPTION_REGEX =
	"""\[SealUtils] Exception triggered by ([a-zA-Z0-9.]+)""".toRegex()

private val POWERGEMS_FAKE_EXCEPTION_REGEX =
	"""\[SealUtils] The exception message is This is a fake exception for debugging purposes\.""".toRegex()

private val POWERGEMS_SEALUTILS_ERROR_REGEX =
	"""\[SealUtils] The error message is ([A-Z_]+)""".toRegex()

private val POWERGEMS_VERSION_REGEX =
	"""PowerGems-([\d.\w\-]+)\.jar//""".toRegex()

private val POWERGEMS_CONFIG_DUMP_REGEX =
	"""\[SealUtils] Dump from: ([a-zA-Z]+) -> ([a-zA-Z]+): (.+)""".toRegex()

private val POWERGEMS_COMMAND_ERROR_REGEX =
	"""\[SealUtils] Exception triggered by ([a-zA-Z0-9.]+Command)""".toRegex()

private val POWERGEMS_INDEX_OUT_OF_BOUNDS_REGEX =
	"""\[SealUtils] The exception message is Index (\d+) out of bounds for length (\d+)""".toRegex()

public class PowerGemsDebugProcessor : LogProcessor() {
	override val identifier: String = "powergems_debug_processor"
	override val order: Order = Order.Earlier
	override suspend fun process(log: Log) {
		val debugException = POWERGEMS_DEBUG_EXCEPTION_REGEX.find(log.content)
		val fakeException = POWERGEMS_FAKE_EXCEPTION_REGEX.find(log.content)
		val errorMessage = POWERGEMS_SEALUTILS_ERROR_REGEX.find(log.content)?.groupValues?.get(1)
		val powerGemsVersion = POWERGEMS_VERSION_REGEX.find(log.content)?.groupValues?.get(1)
		val configDumps = POWERGEMS_CONFIG_DUMP_REGEX.findAll(log.content).toList()
		val commandError = POWERGEMS_COMMAND_ERROR_REGEX.find(log.content)
		val indexOutOfBounds = POWERGEMS_INDEX_OUT_OF_BOUNDS_REGEX.find(log.content)
		
		// Handle fake debug exceptions
		if (fakeException != null && errorMessage == "FAKE_EXCEPTION") {
			log.addMessage(
				"**PowerGems Debug Command Detected** \n" +
					"This appears to be a fake exception generated by PowerGems' debug command. " +
					"This is not a real error and can be safely ignored. " +
					"If you're experiencing actual issues, please run the debug command to help identify the problem."
			)
			return // Don't mark as problem since this is intentional
		}
		
		// Handle real PowerGems exceptions
		if (debugException != null && fakeException == null) {
			val exceptionClass = debugException.groupValues[1]
			
			var errorDescription = "Exception in class: `$exceptionClass`"
			errorDescription += errorMessage?.let { "\nError type: `$it`" } ?: ""
			errorDescription += powerGemsVersion?.let { "\nPowerGems version: `$it`" } ?: ""
			
			// Add specific guidance for command errors
			if (commandError != null) {
				val commandName = commandError.groupValues[1]
				errorDescription += "\n\n**Command Error Detected**"
				
				if (indexOutOfBounds != null) {
					val index = indexOutOfBounds.groupValues[1]
					val length = indexOutOfBounds.groupValues[2]
					errorDescription += "\n• Index out of bounds error: trying to access index $index in array of length $length"
					
					when (commandName) {
						"dev.iseal.powergems.commands.GiveGemCommand" -> {
							errorDescription += "\n• **Fix**: Use correct command syntax: `/givegem <player> <gem_type> [level]`"
							errorDescription += "\n• Common issue: Missing required arguments or invalid gem type"
						}
						else -> {
							errorDescription += "\n• **Fix**: Check command arguments - you may be missing required parameters"
						}
					}
				}
			}
			
			errorDescription += "\n\nCheck the full stack trace above for more details."
			
			log.addMessage("**PowerGems Exception Detected** \n$errorDescription")
			log.hasProblems = true
		}
		
		// Analyze configuration dumps for common issues
		if (configDumps.isNotEmpty()) {
			analyzeConfigurationDumps(log, configDumps)
		}
	}
		private fun analyzeConfigurationDumps(log: Log, configDumps: List<MatchResult>) {
		val configMap = mutableMapOf<String, MutableMap<String, String>>()
		
		// Parse all configuration dumps
		configDumps.forEach { match ->
			val manager = match.groupValues[1]
			val key = match.groupValues[2] 
			val value = match.groupValues[3]
			
			configMap.computeIfAbsent(manager) { mutableMapOf() }[key] = value
		}
		
		val issues = mutableListOf<String>()
		
		// Check for common configuration issues
		configMap["GeneralConfigManager"]?.let { generalConfig ->
			// Check debug mode
			if (generalConfig["debugMode"] == "true") {
				issues.add("Debug mode is enabled - this may impact performance")
			}
			
			// Check if gems decay is disabled on level 1
			if (generalConfig["doGemDecayOnLevel1"] == "false" && generalConfig["doGemDecay"] == "true") {
				issues.add("Gem decay is enabled but disabled for level 1 gems")
			}
			
			// Check max gem level
			generalConfig["maxGemLevel"]?.let { maxLevel ->
				if (maxLevel.toIntOrNull()?.let { it > 10 } == true) {
					issues.add("Very high max gem level ($maxLevel) may cause balance issues")
				}
			}
		}
		
		// Check for disabled gems
		configMap["ActiveGemsConfigManager"]?.let { activeConfig ->
			val disabledGems = activeConfig.filterValues { it == "false" }.keys
			if (disabledGems.isNotEmpty()) {
				issues.add("Some gems are disabled: ${disabledGems.joinToString(", ")}")
			}
		}
		
		// Check cooldown configuration
		configMap["CooldownConfigManager"]?.let { cooldownConfig ->
			val cooldowns = cooldownConfig.values.mapNotNull { it.toIntOrNull() }
			if (cooldowns.isNotEmpty()) {
				val avgCooldown = cooldowns.average()
				if (avgCooldown < 30) {
					issues.add("Low cooldown times (avg: ${avgCooldown.toInt()}s) may cause spam")
				} else if (avgCooldown > 300) {
					issues.add("High cooldown times (avg: ${avgCooldown.toInt()}s) may frustrate players")
				}
			}
		}
		
		// Create summary message with issues
		if (issues.isNotEmpty()) {
			log.addMessage(
				"**PowerGems Configuration Analysis** \n" +
					"Potential configuration issues detected:\n" +
					issues.joinToString("\n") { "• $it" } +
					"\n\n*Review the detailed configuration dump below.*"
			)
		}
		
		// Create paged embeds for configuration dumps
		createConfigurationEmbeds(log, configMap)
	}
	
	private fun createConfigurationEmbeds(log: Log, configMap: Map<String, Map<String, String>>) {
		if (configMap.isEmpty()) return
		
		val managers = configMap.keys.toList()
		val itemsPerPage = 3 // Number of managers per embed
		val totalPages = (managers.size + itemsPerPage - 1) / itemsPerPage
		
		for (pageIndex in 0 until totalPages) {
			val startIndex = pageIndex * itemsPerPage
			val endIndex = minOf(startIndex + itemsPerPage, managers.size)
			val managersOnPage = managers.subList(startIndex, endIndex)
			
			val embedBuilder = StringBuilder()
			embedBuilder.append("**PowerGems Configuration Dump (Page ${pageIndex + 1}/$totalPages)**\n\n")
			
			managersOnPage.forEach { manager ->
				val config = configMap[manager] ?: return@forEach
				embedBuilder.append("**$manager**\n")
				
				// Sort config entries and limit to avoid Discord message limits
				val sortedEntries = config.entries.sortedBy { it.key }.take(20)
				sortedEntries.forEach { (key, value) ->
					val truncatedValue = if (value.length > 50) "${value.take(50)}..." else value
					embedBuilder.append("• `$key`: $truncatedValue\n")
				}
				
				if (config.size > 20) {
					embedBuilder.append("• ... and ${config.size - 20} more settings\n")
				}
				embedBuilder.append("\n")
			}
			
			// Add helpful footer
			if (pageIndex == totalPages - 1) {
				embedBuilder.append("*Use this information to verify your PowerGems configuration.*")
			}
			
			log.addMessage(embedBuilder.toString())
		}
	}
}
